一、实现线程的四种方式
    1、 编写一个类，直接继承java.lang.Thread，重写run方法；run方法中就是分支线程执行的代码
        在需要创建分支线程的位置创建该类对象，调用start()启动分支线程。
        import java.lang.Thread;
        public MyThread extend Thread{
            @Override
            public void run(){}
        }
        MyThread thread=new MyThread();
        thread.start();

    2、 编写一个类，实现java.lang.runnable 接口，实现run方法。这个类并不是线程类，是一个可运行的类，还不是一个线程
        在需要创建分支线程的位置创建该类对象，然后将可运行对象封装成线程对象，调用start()启动分支线程。
        import java.lang.Thread;
        import java.lang.Runnable;
        public MyRunnable implements Runnable{
            @Override
            public void run(){}
        }
        Thread thread=new Thread(new MyRunnable());
        thread.start();

        匿名内部类：通过过一个没有名字的类new对象
        import java.lang.Thread;
        import java.lang.Runnable;
        public static void main(String [] args){
            Thread t=new Thread(new Runnable(){
                    @Override
                    public void run(){}
                }
             );
             t.start();
        }
    3、 实现Callable接口(JDK8新特性)
        优点：可以获取线程的执行结果
        缺点：在获取分支线程执行结果时，当前线程受阻塞，效率较低。
            因为当前线程想要向下执行必须等待futureTask.get()返回结果，而get方法是为了拿分支线程的执行结果，分支线程执行需要时间
        例子：
            创建一个“未来任务类”对象 juc包下(java并发包)
            FutureTask task=new FutureTask(new Callable<V>(){
                public V call(){
                    ...
                    return V;
                }
            });

            Thread t=new Thread(task);
            t.start();
            ...
            Object o=task.get();
    4、线程池的方式
      线程池，其实就是一个容纳多个线程的容器，其中的线程可以重复使用，省去了频繁创建线程对象的操作，因为反复创建线程是非常消耗资源的
      优点：实现自动化装配，易于管理，循环利用资源

二、线程生命周期
    新建状态 new Thread()
        |
        |   start()
       \|/
    就绪状态 就绪状态又叫可运行状态，表示分支线程具有强夺CPU时间片的权力(执行权)
       /|\
        |  抢夺到cpu时间片后，jvm调用run方法
       \|/
    运行状态 run方法的执行标志线程进入运行状态，当cpu时间片用完后，会重新回到就绪状态，
            继续抢占cpu时间片，当再次抢到cpu时间片，会重新进入run方法接着上一次代码继续往下执行
        |
        |   run方法执结束
       \|/
     死亡状态

    阻塞状态： 当一个线程运行中(运行状态)遇到阻塞事件，此时线程会进入阻塞状态，阻塞状态的线程会放弃之前占有的cpu时间片
             当阻塞状态解除，会再次回到就绪状态，重新抢夺cpu时间片
             阻塞方法：synchronized、join、sleep
    锁池（lockPool，不属于生命周期状态）：当运行状态的线程碰到synchronized关键字会放弃cpu时间片，到锁池中找共享对象的对象锁，
            没找到则在锁池中等待，如果找到了线程会进入就绪状态，继续抢占cpu时间片；
三、如何合理的终止一个正在睡眠的线程,很常用
    通过一个布尔值进行控制,不是一个栈控制同一个布尔属性
    注意：以下代码分支线程中止必须是分支线程某次睡眠完后再次循环判断时才能终止
    import java.lang.Thread;
    import java.lang.Runnable;
    public MyRunnable implements Runnable{
        boolean run=true;
        @Override
        public void run(){
            for(int i=0;i<10;i++){
                if(run){
                    System.out.println(i);
                    Thread.sleep(1000*100)
                }else{
                    return;
                }
            }
        }
    }

    Thread thread=new Thread(new MyRunnable());
    thread.start();
    ...
    thread.run=false;
四、线程调度
    1、常见的线程调度模型
        抢占式调度模型：哪个线程优先级较高，抢到的cpu时间片的时间就多一些；java就是用这种机制
        均分式调度模型：每个线程占有的cpu时间片时间长一样，平均分配，众生平等
    2、java中线程的优先级
        1~10    默认5
        int getPriority()
        获取线程的优先级
        void setPriority(int newPriority)
        设置线程的优先级 1~10  默认5
    3、static void yield()
        线程让位，线程放弃抢占的cpu时间片，从运行状态回到就绪状态
    4、void join()
       线程合并，把调用该方法的线程合并到当前线程，当前线程进入阻塞，调用该方法的线程先执行，
       当调用该方法的线程执行结束，当前线程才继续执行
       注意：该方法必须在分支线程start之后才能使用否则当前线程一直处于阻塞状态
            不是栈合并，是栈之间协调等待。
五、多线程并发环境下，数据的安全问题 ！！！！！！！
    1、服务器已支持多线程，服务器已将线程的定义、线程对象的创建，线程的启动等，都已实现，这类代码不需要编写
        重点是代码在这种环境下运行，数据的安全问题
    2、数据的安全问题三条件：
        多线程并发
        有共享数据
        共享数据有修改行为
    3、怎么解决线程安全问题？
        使用”线程同步机制“，实际上就是线程不能并发，必须排队执行
        会牺牲一部分效率，数据安全第一位
    4、线程同步涉及的术语：
        异步编程模型：线程之间各自执行，谁也不需要等谁，多线程并发，效率较高
        同步编程模型：多个线程执行，必须等待其他线程执行结束，线程之间发生了等待关系，效率较低
    5、线程同步机制实现方式：
        java语言中，任何一个对象都有一把锁，其实这把锁就是标记（只是把它叫做锁）
        100个对象100把锁，一个对象一把锁。
        排他锁：synchronized
        互斥锁：
    6、synchronized关键字（排他锁）
      假设两个线程并发，开始执行同步代码的时候肯定一个先一个后
     假设t1先执行，遇到线程同步机制，这时候自动找共享对象的对象锁，并占有这把锁。
     直到同步机制的代码执行结束，才会释放这把锁
     假设t2线程此时也遇到了同步机制，也会占有这把锁，但t1已经占有这把锁，t2只能在同步机制外等待
     t1执行完同步代码，t1归还锁后，t2占有这把锁，才能继续执行同步机制

     同步的代码越少，效率越高
     同步代码块：
         synchronized(){
             线程同步代码：必须线程排队执行，不能并发
         }
         小括号里这个数据必须是多线程共享的数据，才能达到多线程排队
         换句话说：如果想让所有的线程访问synchronized的代码块都排队执行，小括号内直接常量即可（所有线程共享常量）
         如果只是想让部分线程排队执行，写入部分线程共享对象即可
     synchronized出现在实例方法上：
        一定锁的this，不能是其他对象，这种方式不灵活。出现在实例方法上，表示整个方法体都会同步，
        可能无故扩大同步范围，导致程序效率降低，故这种方式不常用
        如果同步的代码是整个方法体，并且共享对象是this，那么就用这种方式
     synchronized出现在静态方法上：
        表示找类锁，类锁永远只有一把，就算创建100个对象，类锁也只有一把
        作用：保证静态变量的安全

    7、java中变量那些有数据安全问题 ！！！
        实例变量：堆中
        静态变量：方法区中
        局部变量：在栈中
        常量：方法区
    以上变量：局部变量永远不会存在线程安全问题。
    因为局部变量不共享。一个线程一个栈，局部变量存储在栈中
    常量不可修改，永远不会存在线程安全问题。

    实例变量在堆中，堆只有一个。静态变量在方法区中，方法区只有一个。
    堆和方法区线程共享，所以可能存在线程安全问题
    8、局部变量使用 StringBuffer 还是 StringBuilder ？
        StringBuilder，局部变量没有线程安全问题；
        因为StringBuffer所有方法都加 synchronized ，所有的方法调用都会到锁池中走一趟，效率低

        同理：ArrayList是非线程安全的，Vector是线程安全的，HashMap和HashSet是非线程安全的，HashTable是线程安全的
六、死锁：
    不出现异常，也不会出现错误，程序一直僵持在哪里，这种错误最难调试
    开发中synchronized最好不要嵌套，一不小心就死锁
七、解决线程安全问题
    不是一上来就是用synchronized，否则会让程序效率降低，用户体验不好，系统的用户吞吐量降低，用户体验差
    1、尽量使用局部变量代替“实例变量和静态变量”
    2、如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了（1个线程1个对象，对象不共享就没有线程安全问题）
    3、如果不能使用局部变量，对象也不能创建多个，这时只能使用线程同步机制
八、守护线程
    java中线程分为两类：用户线程、守护线程(后台线程)
    常见的守护线程：gc
    守护线程特点：
        一般守护线程是死循环，所有的用户线程结束，守护线程自动结束
        注意：main是一个用户线程
    守护线程常用在什么地方：
        后台控制，守护的目的是守护用户线程
        例如：每天00:00的时候系统数据自动备份
            这个需要用到定时器,并且我们可以将定时器设置为守护线程.
            一直在哪里看着,等到00:00的时候系统数据自动备份,所有的用户线程如果结束了,守护线程就自动退出,没必要进行数据备份了。
    如何将线程设置为守护线程
        在线程启动之前将线程设置为守护线程
        void setDaemon(boolean on)
        如果 true，标志着这个线程为守护线程;默认false，为用户线程
九、定时器
    间隔特定的时间执行特定的程序
    在实际开发中，每个队就执行一段特定的程序，这种需求很常见
    java中实现方式有很多种
        1、最原始的方式：可以使用sleep方法，设置睡眠时间，到时间点醒来，执行任务。
        2、java.util.Timer，java定义好的定时器，直接使用即可。
           但基本不用，因为框架在此基础上都实现了，只要进行简单配置即可
           new Timer().schedule(TimerTask(){
                public void run(){
                    执行代码
                }
            },Date firstTime,long period)}
           创建Timer对象，可以将Timer设置为守护线程，执行schedule方法；
                TimerTask抽象类，编写一个类继承该抽象类实现run方法即可
                firstTime：首次执行时间
                period:间隔多少毫秒执行一次
        3、ScheduledExecutorService 是JAVA 1.5后新增的定时任务接口，它是基于线程池设计的定时任务类，每个调度任务都会分配到线程池中的一个线程去执行（任务是并发执行，互不影响）
          ScheduledExecutorService 可以实现Timer具备的所有功能，并解决了 Timer类存在的问题
          注：只有当执行调度任务时，ScheduledExecutorService才会真正启动一个线程，其余时间ScheduledExecutorService都是出于轮询任务的状态
        4、SSM 就是用的 SpringTask，但功能单一
        5、分布式定时任务技术选型
          上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。
          如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。
          Quartz
              优点：可以与 Spring 集成，并且支持动态添加任务和集群。
              缺点：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）
          xxl-job：
              XXL-JOB 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，
              根据 XXL-JOB 官网介绍，其解决了很多 Quartz 的不足。
              优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。
              缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：xxl-job issue277）。
          PowerJob

十、Object类中的wait和notify
    1、wait和notify不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方法是Object类中自带的
      wait和notify建立在synchronized线程同步基础上，因为多线程操作共享对象，有线程安全问题
      wait方法会让调用该方法的对象上活跃的线程进入等待状态，无期限等待，直到被唤醒为止，并释放占有的对象锁（synchronized的共享对象）
      notify方法会唤醒调用该方法的对象上的等待状态线程，但不会释放占有的对象锁
    2、wait方法作用
        Object o=new Object();
        o.wait();
        让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止
        o.wait();方法的调用，会让"当前线程(正在o对象上活动的线程)“进入等待状态
    3、notify()方法作用
        Object o=new Object();
        o.notify();
        唤醒正在o对象上等待的线程
        还有个 notifyAll() 方法
        唤醒正在o对象上处于等待的所有线程
    4、什么是”生产者和消费者模式“
        生产线程负责生产，消费线程负责消费
        生产线程和消费线程要达到均衡
        这是一种特殊的业务需求，在这种特殊情况下需要使用wait和notify方法
    多线程并发的开发技巧：任何代码位置都考虑一下线程的cpu时间片消耗完了，线程回到就绪状态没抢到下次的执行权，让其他线程抢到了