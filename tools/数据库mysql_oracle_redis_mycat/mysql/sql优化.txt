mysql--高级
一、存储引擎
	1、指定mysql管理数据的方式
	2、使用：
		数据库中各表均为（建表时）指定的存储引擎来处理
		服务器可用的引擎依赖于以下因素：
			mysql版本
			服务器在开发时如何配置：在Windows下叫my.ini，在MySQL的安装根目录下；在Linux下叫my.cnf
			启动选项：启动参数
		了解当前有那些存储引擎可用，使用命令 show engines
		Engine（引擎）  | Support（支持） | Comment （说明）| Transactions（事务） | XA	| Savepoints（回滚点）
		
		在创建表时，可使用ENGINE选项为CREATE TABLE语句显式指定存储引擎
			create table tablename (no int) engine = myisam;
		如果在创建表时没有显式指定存储引擎，则该表使用当前默认的存储引擎	
		默认的存储引擎可在my.cnf/my.ini配置文件中使用default-storage-engine选项指定
		现有表的存储引擎可使用ALTER TABLE语句来改变
			alter table tablename engine = INNODB;
		查看表的存储引擎：show create table 表名;
	3、常用的存储引擎
		MyISAM:
			特征：使用三个文件表示每个表
				表结构：.frm
				表记录：.myd
				表索引：.myi
		InnoDB:
			特征：表结构、表记录、表索引：.frm
				提供全ACID兼容(事务四个特征)
				用COMMIT、SAVEPOINT、ROLLBACK支持事务处理
		MyISAM和InnoDB区分：
			1、表的存储形式不同
				MYISAM：表结构文件(.frm)、表行数据(.MYD)、索引(.MYI)
				InnoDB:表结构文件、表行数据、索引 存储在一个文件中 .frm
				--->数据量大的时候使用MYISAM
			2、是否支持事务	
				事务：文件备份
				MYISAM：不支持事务
				InnoDB：支持事务
				InnoDB更适用于增删改操作(DML)
		MEMORY存储引擎
			使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得MEMORY存储引擎非常快，
			特征：
				在数据库目录内，每个表均以.frm格式的文件表示
				表数据及索引被存储在内存中
				表级锁机制
				不能包含TEXT或BLOB字段

	4、存储引擎的选择
		MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。
		如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制。
		可使用MEMORY存储引擎来存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成的数据
		
二、索引
	1、为什么使用索引？
		提高查询速度，用户看到数据过程：1、扫描数据	2、取出数据
	2、索引原理
		索引是一个数组，存放的某个字段下数据，这些数据按照升序或则降序存放在索引中
		为了避免采用全表扫描方式定位数据行，可以通过二分法查找在索引中快速给出定位数据行行数提供给WHERE
		索引被用来快速找出在一个列上用一特定值的行。没有索引，MySQL不得不首先以第一条记录开始，然后读完整个表直到它找出相关的行。表越大，花费时间越多。对于一个有序字段，可以运用二分查找（Binary Search），这就是为什么性能能得到本质上的提高。MYISAM和INNODB都是用B+Tree作为索引结构（主键，unique 都会默认的添加索引）
	3、什么时候使用索引
		表中该字段中的数据量庞大
		经常被检索，经常出现在where子句中的字段
		经常被DML操作(增删改)的字段不建议添加索引

	4、索引的操作命令
		1、查看索引
			show index from 表名;
		2、创建索引
			create  index 索引名 on 表名(列名); 
			alter table 表名 add index 索引名 (列名);
		3、删除索引
			drop index 索引名 on 表名;
			alter table 表名 drop index 索引名;
			alter table 表名 drop primary key;//只适用于删除主键的索引
		4、执行计划（查看本次查询过程中得到定位数据行方式是否是通过索引得到）
			explain 查询语句;
			执行效率级别:通过type属性来描述当前查询语句执行效率
				all	<	index	<	range	<	ref	   <  const
				all:全表扫描,未使用索引
				index:全表扫描，定位到数据行时索引查询返回结果集，有一定提升但意义不大
				range:使用到索引，并且得到多个数据行，
					  但不稳定，数据发生改变时可能导致索引失效；查询数据行数大于总数据行的三分之一时会放弃索引
				ref:使用索引，并且每次查询只能得到一个数据行。执行效率稳定，执行速度快。
					达到ref级别，要求字段值唯一(主键/unique)，很难实现
				const:常量
	5、索引失效：在where子句中
		在索引字段上进行数学运算：
		在索引字段上使用函数进行操作
		如果在索引中定位数据行行数达到总行数1/3时，mySql自动放弃索引
		模糊查询：前置条件模糊查询，并不会导致索引失效；后置条件模糊查询和包含模糊查询，到会导致索引失效
			前置模糊查询：'s%'
		索引字段隐式转换：mysql中字符串类型可以转换成任意类型的数据
		
	6、MySQL中创建主键索引时字段的先后顺序是非常重要的。
	   复合主键的第一位字段在查询时才可以用到索引，后面的字段在查询时都用不到索引。
	   如果要频繁查询时，则应另外创建索引。
三、视图
	为什么使用视图？
		平时编写sql。有些sql非常复杂的，需求决定一些sql语句需要在多个地方使用，会给维护带来成本。
		视图解决该问题，将复杂的结果集存储在磁盘上，下次使用直接读取该文件
	注意：mysql不支持嵌套的内部的子查询创建视图，oracle支持
	1、视图概念
		将select语句查询的结果集保存在磁盘上
	2、作用:
		1、减少重复sql语句的编写操作
		2、屏蔽操作的表文件结构，隐藏业务解决方案（可被用来对不同用户显示不同的表的内容）
			表设计根据业务来设计
	3、使用
		1、创建视图：
			create view 视图名称 as select语句；
			注意mysql不支持子查询创建视图
		2、修改视图
			alter view  视图名称 as select语句;
		3、删除视图
			drop view if exists 视图名称;
			
四、事务（transaction）：基于业务
	1、定义：很多个DML（增删改sql）语句组合
	2、原则：
		保证事务的前后统一，要么同时成功，要么同时失败
	3、事务的本质：
		文件的备份
			转帐前：张三 10000 李四 0
			
			开始转帐  可能出现异常，也可能没有
			转账结束  如果出现异常，恢复到转帐前备份状态
		原则：要么同时成功，要么同时失败
			  如果失败，需要回滚(可能有多个回滚点)
			  如果出现异常，需要回滚
			  
		InnoDB存储引擎管理的表文件，在进行数据更改操作时需要先对表中数据进行一次备份，
		然后再进行具体更改，更改完毕后是否使用备份来取消本次操作就由事务对象进行负责
	
	4、事物的特征：ACID
		原子性、一致性、隔离性、持久性
		原子性、一致性：事务保证前后统一并且不能分割
		持久性：必须将事务结束后的数据磁盘化
		隔离性：事务和事务之间不能相互干扰
	
	5、mysql中事务的使用：
		手动提交:
			开启事务(文件备份):
				start transaction;
			查询表数据:
				select语句;
			修改表数据:
				update/delete/insert语句;...
			确认表数据:
				select语句;
			若出现异常，回滚操作:
				rollback;
			提交事务:
				commit;
		自动提交:
			不推荐使用，因为数据库每次DML都提交事务。最好手动提交;
			关闭自动提交设置;
			set autocommit=OFF;
			set autocommit= 0;
			查看配置是否生效
			SHOW VARIABLES LIKE '%auto%';
			开启自动提交事务
			set autocommit=1;
	
	6、事务的隔离级别
		隔离性：会有隐患
		干扰：多个人操作一张表的时候可能会出现如下情况
			针对更新（修改）操作
				脏读：事务A操作一张表更新数据了，还没提交，这时事务B读取这张表的脏数据
				不可重复读：事务A操作一张表更新数据了，还没提交，事务B读取这张表的数据，
							事务A提交事务，事务B再次读取这张表的数据，事务B前后读取数据不一致，
			针对插入或删除操作
				幻读：事务A操作一张表进行插入或删除操作，没有提交，此时事务B查询数据
		
		InnoDB 实现了四个隔离级别，用以控制事务所做的修改，并将修改通告至其它并发的事务
		事物的隔离级别：
										脏读		不可重复读		幻读
			读未提交（READ UNCOMITTED）	×				×			×	
				允许一个事务可以看到其他事务未提交的修改。
			读已提交（READ COMMITTED）	√				×			×			
				允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。
			可重复读（REPEATABLE READ） √				√			×
				确保如果在一个事务中执行两次相同的SELECT语句，都能得到相同的结果，不管其他事务是否提交这些修改
			串行化（SERIALIZABLE）		√				√			√
				将一个事务与其他事务完全地隔离
			
			串行化的实现需要以消耗资源为代价，mysql默认可重复读
	7、修改mysql事务的配置：
		1、mysql配置文件my.ini或my.cnf中
			[mysqld]
			transaction-isolation = READ-COMMITTED
		2、命令方式查看隔离级别
			查看当前会话的隔离级别
				 SELECT @@tx_isolation;
			查看全局的隔离级别：
				SELECT @@global.tx_isolation;
		3、命令修改隔离级别
			全局的隔离级别
				SET GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别;
			会话的隔离级别
				SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;
				
五、DBA（创建用户、授权、回收权限）详情看讲义
六、数据库三范示
	1、给表上主键
	2、第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖。
	3、建立在第二范式基础上的，非主键字段不能传递依赖于主键字段。（**不要产生传递依赖**）
	
	也就是说表的设计：1-1：一张表	1-n：两张表(子表设置外键)	n-n:三张表		
	
	补充：如果数据冗余，拆分表，但有时就需要冗余查询，速度快；因为关联查询慢
	
	
	
	存储过程:阿里巴巴开发文档不建议使用
	
	sql优化
		能够使用where条件过滤的尽量在wehere过滤，比分组过滤效率高；虽然where和having能相互替换

	自增序列
	数据库锁表
	集群